<resources>

    <string name = "app_name">Data Structures and Algorithms</string>
    <string name = "topics">Topics</string>
    <string name = "title_activity_topic">Data Structures and Algorithms with Java</string>

    <string name = "array_topic_activity">Arrays</string>


    <string name = "array_introduction">Array Introduction</string>


    <string name = "array_introduction_paragraph">
        An array stores a sequence of values that are all of the same type.
        We want not just to store values but also to be able to quickly access each individual value.
        \n
        The method that we use to refer to individual values in an array is to number and then index themâ€”if we have N values,
        we think of them as being numbered from 0 to N-1.
        \n
        \n
        Arrays have a fixed size, which means that they are mainly used when you know how many objects will be required.
        Ie. array with a length of 12 for months in the year.
        \n
        Arrays work with memory allocation in Java but not all languages.
        When you use the new keyword to create an array, Java reserves space in memory for it.
        \n
        As you will see in the next few topics, when using an array,
        you must be very aware of the size and bounds of an array. Otherwise you will get an Out Of Bounds error.


    </string>

    <string name="array_declaration">Declaring an Array</string>
    <string name="array_declaration_paragraph">
        The following shows the declaration of an array, but the contents of the array would be set to 0 by default.
        \n
        \n
        int[] myIntArray = new int[3];
    </string>
    <string name="array_initialisation_paragraph">

        \n
        \n
        The following shows the declaration as well as initialization of the values in the array.
        \n
        The length is defined by the amount of objects (in this case numbers) within the curly brackets.
        \n
        \n
        int[] myIntArray = {1,2,3};
    </string>

    <string name="array_select_sort">Select Sort</string>
    <string name="array_select_sort_button_text">Submit values</string>
    <string name="array_select_sort_paragraph">
        The algorithm divides the input list into two parts:
        the sublist of sorted items, which is built up from left to right,
        and the sublist of unsorted items that occupy the rest of the list.
        Initially, the sorted sublist is empty and the unsorted sublist is the entire input list.
        \n
        The algorithm proceeds by finding the smallest (or largest,
        depending on sorting order) element in the unsorted sublist,
        exchanging it with the leftmost unsorted element (putting it in sorted order),
        and moving the sublist boundaries one element to the right.
        \n
        Select sorts complexity is rated for best, worst and average case as O(n^2).
        It is mainly used for real-time computing as it\'s behaviour is identical no matter what.
    </string>

    <string name="array_bubble_sort">Bubble Sort</string>
    <string name="array_bubble_sort_paragraph">
        From the start, compare every adjacent pair, swap their position if they are not in the right order
        (the right value is smaller than the left). After each iteration, one less element
        is needed to be compared until there are no more elements left to be compared.
        \n
        \n
        Bubble sorts complexity comes in at an O(n^2) for it\'s worst, average and best case.
        It is mainly used when a list is mostly sorted, with only a few items out of place.
    </string>


    <string name="array_merge_sort">Merge Sort</string>
    <string name="array_merge_sort_paragraph">
        First divide the list into the smallest unit (1 element),
        then compare each element with the adjacent list to sort and merge the two adjacent lists.
        Finally all the elements are sorted and merged.
        \n
        Merge sort is very quick and efficient. It\'s worst and average complexity time is O(n log n).
        It\'s worst case is 39% fast than quick sorts average case.
        \n
        The downside to it, is that it uses up a lot of space so if that is an issue,
        other options should be considered.
    </string>

    <string name="array_linear_search">Linear Search</string>
    <string name="array_linear_search_paragraph">
        Linear Search is the most easiest way of searching elements from an Array.
        In this approach we iterate over an Array and  try every element in it until,
         we have found the element or until we reach the end of the collection or Array.
        Here is an example.

        Linear Search iterate over each element until it found the right element,
        hence it has a variable best case and a fixed average and worst case complexity of O(n).

    </string>

    <string name="array_binary_search">Binary Search</string>
    <string name="array_binary_search_paragraph">
        Binary search is more efficient and merely used search algorithm in java programming.
        To implement Binary search we must have an sorted array or collection.
        Binary Search searches element in middle of the Array.
        The array is than divided into sub-array in each iteration accordingly,
        if the element is greater than the middle element or smaller than the middle element,
        the respective sub-array is used for further searching.
        See the code section for sample code

        Binary Search divided the search space into half in each iteration and hence has a O(log n) complexity.
    </string>

    <string name="linkedList_topic_activity">LinkedLists</string>

    <string name="linkedList_introduction">Introduction</string>
    <string name="linkedList_introduction_paragraph">
                    A linkedList is a data structure, of a sequence of linked nodes, that stores a
                    sequence of elements that can be repeated.
                    \n
                    \n
                    Each node in a LinkedList is composed of a data item and a reference or
                    references depending on its implementation.
                    \n
                    \n
                    The java standard library implements a doubly LinkedList. LinkedList are generally
                    faster at inserting and removing elements,especially at either end of the list,
                    over their counter part ArrayList.
                    \n
                    \n
                    Through out the topics and examples given in this topic we will use singly linked
                    nodes until doubly linked are required. These are described later on in declaring
                    a LinkedList
    </string>

    <string name="linkedList_declaration">Declaration</string>
    <string name="linkedList_declaration_paragraph">
                      A LinkedList can be created though the use of a singly or doubly linked nodes.
                      A node is made up of a data item and a node or nodes referencing the next or
                      previous nodes in a sequence.
                      An example of declaring singly and doubly linked list can be found in the Code section.
                        \n
                      As you have seen in both implementations for a LinkedList, both nodes use a
                      generic data type (T). This allows the linked node and LinkedList to contain
                      any Object of the same type to be placed within the LinkedList.
                      \n
                      \n
                      The next and previous nodes are used to reference the adjacent nodes in the LinkedList
                      \n
                      \n
                      We will see later how to add / remove references.
                      \n
                      To declare a LinkedList from the standard java library import the java package
                      java.util.LinkedList; and create a LinkedList variable defining what object it
                      can take.
                      \n
              </string>

    <string name = "linkedList_insertion">Insertion</string>
    <string name = "linkedList_insertion_paragraph">
                    You can add an item to a LinkedList at the start, middle or end. LinkedList has
                    an efficient way of adding nodes to either the start and end of collections of nodes.
                    \n
                    \n
                    To insert a node and item to the start of a LinkedList you can simply get the head
                    to reference itself as the next node and place the item you want as the new head item.
                    \n
                    \n
                    An example of insertion can be found in the code section.

                    As you can see its is one simple instruction being carried out. Inserting at the
                    beginning, is very similar to inserting at the end.
                    \n
                    However adding into the middle of a LinkedList becomes a little less efficient as the
                    list grows. When adding to the middle you must read through x number of nodes from
                    the start until you get to the position you want to add an item.

                    Once again, see the code section for an example of this.

                    \n
                   </string>

    <string name = "linkedList_removal">Removal</string>
    <string name = "linkedList_removal_paragraph">
                    You can remove a node from any point in a LinkedList. Removing the first element
                    in a LinkedList is very straightforward.All you do is get the head to reference
                    the next node instead of the current one.
                    \n
                    \n
                    In the case above, we check to see if there is anything in the list to remove and
                    if there is then we simply reference the next node. This removes any reference to
                    the head node and so it\'s removed from memory. Something very similar can be done
                    for removing nodes from the middle of a LinkedList
                    \n
                    \n

                    The code for removing from the middle assumes length of the LinkedList is being tracked
                    using some sort of count variable which is being increased and decreased accordingly.
                    For removing from an index you first check if the index is within bounds.You then check if the
                    index is the head if so you can remove it straight away and finish the method efficiently.
                    If you have to go looking for an index you start with temp at head and next at
                    the node after head so it stays once step ahead. As you loop to the required index,
                    you move the nodes along the LinkedList. When the loop finishes, next has the
                    required node.From there we tell temp to replace its next node with the required node.
                     \n
                     \n
                    Removing central nodes is a lot more complex than removing the first node. When
                    removing the last singly linked node, you must go through the entire LinkedList
                    to find the second last node. To counteract this, doubly LinkedLists can be used.
                    Instead of only referencing the next node we could also references the previous
                    node that it is connected to. This means that to remove the last node in a LinkedList,
                    we only have to tell the Tail pointer to reference the previous node instead and
                    remove its reference to the last node.
                    \n
                    See the Code section for all of the above
                     \n
                    \n
                    Of course if you were to implement doubly LinkedList, you would have to do it for
                    both removal of the first and middle nodes. These are not implemented in this tutorial.
    </string>

    <string name = "linkedList_rotation">Rotation</string>
    <string name = "linkedList_rotation_paragraph">
        There are many alterations you may want to do to a LinkedList for many reasons, and on of these
        alterations maybe to rotate the list right or left by a certain amount. To rotate a LinkedList
        you have to alter the both the head and tail of a list, in different orders depending on which
        way to wish to rotate the list.
        \n
        \n
        To rotate left you must move the head item to the end of the LinkedList and more the heads next
        reference to the head.
        \n
        \n
        To rotate right to apply the same logic but in the reverse order. To rotate right you move the
        last item to the head and move the second last reference to the tail of the list. This implementation
        would require a doubly linked node for the best results in speed and time.
        \n
        The code section shows how to achieve this.
    </string>
    <string name="button_text">Submit</string>
    <string name="Code_topic_activity">Code</string>
    <string name="previous">Previous</string>
    <string name="next">Next</string>
    <string name="code_merge_sort">Merge Sort Code</string>
    <string name="code_bubble_sort">Bubble Sort Code</string>
    <string name="code_select_sort">Select Sort Code</string>
    <string name="code_linear_search">Linear Search Code</string>
    <string name="code_binary_search">Binary Search Code</string>
    <string name="code_LinkedList_Declaration">LinkedList Declaration Code</string>
    <string name="code_adding_a_node">Adding A Node Code</string>
    <string name="code_removal">Removing a node Code</string>
    <string name="code_rotation">Rotation Code</string>


    <string name="code_merge_sort_paragraph">
    \n
        public class MergeSort {
    \n
    \t\t    public static int[] mergeSort(int [] list) {
    \n
    \t\t\t\t    if (list.length &lt;= 1) {
    \n
    \t\t\t\t\t\t    return list;
    \n
    \t\t\t\t    }
    \n
    \n
    \t\t\t\t    int[] first = new int[list.length / 2];
    \n
    \t\t\t\t    int[] second = new int[list.length - first.length];
    \n
    \t\t\t\t    System.arraycopy(list, 0, first, 0, first.length);
    \n
    \t\t\t\t    System.arraycopy(list, first.length, second, 0, second.length);
    \n
    \t\t\t\t    mergeSort(first);
    \n
    \t\t\t\t    mergeSort(second);
    \n
    \t\t\t\t    merge(first, second, list);
    \n
    \t\t\t\t    return list;
    \n
    \t\t}
    \n
    \t\t   private static void merge(int[] first, int[] second, int [] result) {
    \n
    \t\t\t\t    int iFirst = 0;
    \n
    \t\t\t\t    int iSecond = 0;
    \n
    \t\t\t\t    int j = 0;
    \n
    \t\t\t\t    while (iFirst &lt; first.length &amp;&amp; iSecond &lt; second.length) {
    \n
     \t\t\t\t\t\t   if (first[iFirst] &lt; second[iSecond]) {
     \n
     \t\t\t\t\t\t\t\t   result[j] = first[iFirst];
     \n
     \t\t\t\t\t\t\t\t   iFirst++;
     \n
     \t\t\t\t\t\t   }
     \n
     \t\t\t\t\t\t   else {
     \n
     \t\t\t\t\t\t\t\t   result[j] = second[iSecond];
     \n
     \t\t\t\t\t\t\t\t   iSecond++;
     \n
     \t\t\t\t\t\t   }
     \n
     \t\t\t\t\t\t   j++;
     \n
     \t\t\t\t   }
     \n
     \t\t\t\t   System.arraycopy(first, iFirst, result, j, first.length - iFirst);
     \n
     \t\t\t\t   System.arraycopy(second, iSecond, result, j, second.length - iSecond);
     \n
     \t\t  }
    </string>
    <string name="code_bubble_sort_paragraph">
    public void bubbleSort(int[] arr) {
    \n
    \t\t   boolean swapped = true;
    \n
    \t\t   int j = 0;
    \n
    \t\t   int tmp;
    \n
    \t\t   while (swapped) {
    \n
    \t\t\t\t    swapped = false;
    \n
    \t\t\t\t    j++;
    \n
    \t\t\t\t    for (int i = 0; i &#60; arr.length - j; i++) {
    \n
    \t\t\t\t\t\t          if (arr[i] > arr[i + 1]) {
    \n
    \t\t\t\t\t\t\t\t                tmp = arr[i];
    \n
    \t\t\t\t\t\t\t\t                arr[i] = arr[i + 1];
    \n
    \t\t\t\t\t\t\t\t                arr[i + 1] = tmp;
    \n
    \t\t\t\t\t\t\t\t                swapped = true;
    \n
    \t\t\t\t\t\t          }
    \n
    \t\t\t\t    }
    \n
    \t\t    }
    \n
        }
    \n
    </string>
    <string name="code_select_sort_paragraph">

    public static int[] doSelectionSort(int[] arr){
    \n
    \t\t
    \t\t    for (int i = 0; i &lt; arr.length - 1; i++){
    \n
    \t\t    int index = i;
    \n
    \t\t    for (int j = i + 1; j &lt; arr.length; j++)
    \n
    \t\t\t\t    if (arr[j] &lt; arr[index]){
    \n
    \t\t\t\t\t\t        index = j;
    \n
    \t\t\t\t    }
    \n

    \t\t\t\t    int smallerNumber = arr[index];
    \n
    \t\t\t\t     arr[index] = arr[i];
    \n
    \t\t\t\t     arr[i] = smallerNumber;
    \n
    \t\t    }
    \n
    \t\t    return arr;
    \n
        }
    </string>
    <string name="code_linear_search_paragraph">
       \n
        \t\t int linearSearch(int numbers[], int x) {
        \n
        \t\t\t\t  int foundIndex = 0;
        \n
        \t\t\t\t  for (int i = 0; i &lt; numbers.length; i++) {
        \n
        \t\t\t\t\t\t   if (numbers[i] == x) {
        \n
        \t\t\t\t\t\t\t\t    foundIndex = i;
        \n
        \t\t\t\t\t\t}
        \n
        \t\t\t\t  }
        \n
        \t\t\t\t  return foundIndex;
        \n
        \t\t }
        \n}
    </string>
    <string name="code_linkedList_declaration_paragraph">

         \n
          public static class Singly_Linked_Node T {
        \n
          \t\t  T item;\n
          \t\t  Node T next;
        \n
          \t\t  Node(T item, Node T next){
        \n
          \t\t\t\t    this.item = item;
        \n
          \t\t\t\t    this.next = next;
        \n
          \t\t  }
        \n
          }
        \n
        \n

        \t\t      T item;
        \n
        \t\t      Node T previous;
        \n
        \t\t      Node T next;
        \n

        \t\t      Node(T item, Node T previous, Node T next){
        \n
        \t\t\t\t         this.item = item;
        \n
        \t\t\t\t     this.previous = previous;
        \n
        \t\t\t\t          this.next = next;
        \n
        \t\t      }
        \n
        }
        \n
        \n
        \n
        public class LinkedList T {
        \n

        \t\t  private static class Node T { &#8230;}
        \n

        \t\t      Node T head, last;
        \n

        \t\t      //Methods for add and remove for LinkedList.
        \n
        }
        \n
    </string>
    <string name="code_removal_paragraph">
        \n
        public void removeFirst(){
        \n
        \t\t    if(head != null){
        \n
        \t\t\t\t        head=head.next;
        \n
        \t\t    }
        \n
        }
        \n
        \n
        \n
        public void removeIndex(int index){
        \n
        \t\t   temp = head;
        \n
        \t\t   next = head.next
        \n

        \t\t   if(index > length){
        \n
        \t\t\t\t       return;
        \n
        \t\t   }
        \n
        \t\t   else if(index == 1){
        \n
        \t\t\t\t       removeFirst();
        \n
        \t\t   }
        \n
        \t\t   for(int i = 1; i (less then) index;i++){
        \n
        \t\t\t\t       temp = temp.next;
        \n
        \t\t\t\t       next = next.next;
        \n
        \t\t   }
        \n
        \t\t   temp.next = next.next;
        \n
        }
        \n
        \n
        \n
        public void removeLast(){
        \n
        \t\t    last = last.previous;
        \n
        \t\t    last.next = null;
        \n
        }
        \n
    </string>
    <string name="code_rotation_paragraph">
        \n
        public void leftRotate(){
        \n
        \t\t    if(head==tail){
        \n
        \t\t\t\t      return;
        \n
        \t\t    }
        \n
        \t\t     else{
        \n
        \t\t\t\t        tail.next= new Node(head.item,null);
        \n
        \t\t\t\t        tail=tail.next;
        \n
        \t\t\t\t        head=head.next;
        \n
        \t\t     }
        \n
        }
        \n
        \n
        \n
        public void rightRotate(){
        \n
        \t\t    if(head==tail){
        \n
        \t\t\t\t        return;
        \n
        \t\t    }
        \n
        \t\t    else{
        \n
        \t\t\t\t        T temp = tail.item;
        \n
        \t\t\t\t        last = last.previous;
        \n
        \t\t\t\t        last.next = null;
        \n
        \t\t\t\t        head = new Node(temp,head,null);
        \n
        \t\t    }
        \n
        }\n
    </string>
    <string name="code_binary_search_paragraph">

         \n
        \t\t int searchElementBinary(int numList[], int toSearch) {
        \n
        \t\t\t\t  int startIndex = 0;
        \n
        \t\t\t\t  int endIndex = numList.length - 1;
        \n
        \t\t\t\t  int midindex = (startIndex + endIndex) / 2;
        \n
        \t\t\t\t  int midElement = numList[midindex];
        \n
        \t\t\t\t  int foundIndex = 0;
        \n
        \t\t\t\t  while (startIndex &lt;= endIndex) {
        \n
        \t\t\t\t\t\t   if (midElement &lt; toSearch) {
        \n
        \t\t\t\t\t\t\t\t    startIndex = midindex + 1;
        \n
        \t\t\t\t\t\t\t\t    midindex = (startIndex + endIndex) / 2;
        \n
        \t\t\t\t\t\t\t\t    midElement = numList[midindex];
        \n
        \t\t\t\t\t\t   }
        \n
        \t\t\t\t\t\t  else if (midElement > toSearch) {
        \n
        \t\t\t\t\t\t\t\t  endIndex = midindex - 1;
        \n
        \t\t\t\t\t\t\t\t  midindex = (startIndex + endIndex) / 2;
        \n
        \t\t\t\t\t\t\t\t  midElement = numList[midindex];
        \n
        \t\t\t\t\t\t  }
        \n
        \t\t\t\t\t\t else {
        \n
        \t\t\t\t\t\t\t\t foundIndex = midindex;
        \n
        \t\t\t\t\t\t\t\t break;
        \n
        \t\t\t\t\t\t  }
        \n
        \t\t\t\t }
        \n
        \t\t\t\t return foundIndex;
        \n
        \t\t}
        \n

    </string>
    <string name="code_adding_a_node_paragraph">

        \n
            public void insertStart(T item){
        \n
        \t\t     if(head==null){
        \n
        \t\t\t\t         head = new Node (item,null);
        \n
        \t\t\t\t         head=last;
        \n
        \t\t     }
        \n
        \t\t     else{
        \n
        \t\t\t\t         head = new Node (item,head);
        \n
        \t\t     }
        \n
           }
        \n
        \n
        \n
        public void insertLast(T item){
        \n
        \t\t    last.next = new Node(item,null);
        \n
        }
        \n
            \n

        public boolean insertMiddle(int index;T item){
        \n
        \t\t    Node T temp = head;
        \n
        \t\t     int place;
        \n
        \t\t     for(place=0;place (less then) index &amp; temp.next!= null; place++ ){}
        \n
        \t\t     if(place == index){
        \n
        \t\t\t\t         temp= new node(item,temp);
        \n
        \t\t\t\t         return true;
        \n
        \t\t     }
        \n
        \t\t     return false;
        \n
        }
    </string>

</resources>


